                             CS225 Final Project Results 

The first achievement in this project was the successful construction of a graph storing all airport objects created from the airport dataset as nodes and routes connecting them as edges. Multiple tests were run in main, and then later in tests.cpp,  to prove that our graph exactly mirrors how data is presented in the openFlights dataset. One of the tests was to display airports that have an incoming flight (route) from a certain airport (node). By comparing both routes and airport dataset, the outputs exactly match the datasets. Our graph was implemented using an adjacency list which is known to be more efficient for a BFS traversal and also Dijkstra’s algorithm which acts similar to BFS.  Next, we successfully implemented BFS traversal. BFS traverses all the airports along the routes and returns a vector of airports in the traversal order. The size of the vector obtained from BFS was 6033, which is the number of airports in our dataset.

Dijkstra’s Algorithm was a member function of the Graph class and was implemented using a min-heap priority queue of Route objects. To keep track of distances and previous Airports we made 2 maps: one of them mapping an airport ID to its corresponding airport’s distance from the source, and another one that mapped an airport ID to its previous airport’s ID in the traversal. We set the default value of the distance map entries to infinity, except the one corresponding to the source airport, which we made 0. Then, we did cost computation and comparison for each of the neighbors of the source and subsequent airports. To get the path, we backtracked from the destination to the source airport, pushing the airports along the way into a vector.

These were our results when we ran our code from O’Hare Airport to Goroka Airport:

![alt text](https://github-dev.cs.illinois.edu/cs225-fa21/vasilis2-suhaasn3-quinnd2-yacineb2/blob/main/drawUtils/map.png?raw=true)

The image shown above is the PNG output of our last algorithm, the world projection algorithm. The main part of  this algorithm is using a world map projection to convert the real life location of airports given their latitude and longitude into (x,y) pixel coordinates of the world map canvas image. We decided to use the Mercator projection due its simplicity but simplicity comes with a cost as the coordinates were not a 100 percent accurate in addition to uncertainties present in the original data. Despite these approximations, the pixel coordinates for airports were pretty deterministic as we can see, for instance, O’hare Airport being located near lake Michigan. After locating the airports, we drew the lines connecting them to represent the flights’ path, and that was done by modifying the original world map PNG. Next, we took advantage, rightfully, of PNG, Image, StickerSheet classes used in class specifically in mp_stickers MP. This allowed us to use all the drawing functionalities we already implemented during the semester. Specifically adding dots and city names to label the airports based on dot and letter stickers we created. 

  
  
  The graphic design is not really eye-catching but we preferred using our own “from-scratch” classes rather than graphing frameworks. The most important fact is that the airports are located and labeled well and the path is clear and understandable and we were able to achieve that. This algorithm also helped us see how Dijkstra’s output represents the shortest path. At some point, Dijkstra was bugging and we could tell from the world map projection that the “expected” shortest path was not looking as a shortest path at all. So finally, the algorithms we chose for our project turned out to be interconnected and serve for one common goal. 

